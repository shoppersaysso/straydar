<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: components/Image/Image.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: components/Image/Image.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import React, {Component, PropTypes} from 'react';
import cloudinary, {Util} from 'cloudinary-core';
import CloudinaryComponent from '../CloudinaryComponent';
import {debounce, firstDefined, closestAbove, requestAnimationFrame, equals, isElement} from '../../Util';

/**
 * A component representing a Cloudinary served image
 */
class Image extends CloudinaryComponent {
  constructor(props, context) {
    function defaultBreakpoints(width, steps = 100) {
      return steps * Math.ceil(width / steps);
    }

    super(props, context);
    this.handleResize = this.handleResize.bind(this);

    let state = {responsive: false, url: "", breakpoints: defaultBreakpoints};
    this.state = Object.assign(state, this.prepareState(props, context));
  }

  /**
   * Retrieve the window or default view of the current element
   * @returns {DocumentView|*}
   */
  get window() {
    let windowRef = null;
    if(typeof window !== "undefined"){
      windowRef = window
    }
    return (this.element &amp;&amp; this.element.ownerDocument) ? (this.element.ownerDocument.defaultView || windowRef) : windowRef;
  }

  shouldComponentUpdate( nextProps, nextState){
    return !( equals(this.props, nextProps) &amp;&amp; equals(this.state, nextState));
  }

  componentWillReceiveProps(nextProps, nextContext) {
    let state = this.prepareState(nextProps, nextContext);
    this.setState(state);
  }

  /**
   * Generate update state of this element
   * @param {Object} [props=this.props]
   * @param {Object} [context=this.context]
   * @returns {Object} state updates
   */
  prepareState(props = this.props, context = this.context) {
    let options = CloudinaryComponent.normalizeOptions(context, props);
    let url = this.getUrl(options);
    let state = {};
    if (options.breakpoints !== undefined) {
      state.breakpoints = options.breakpoints;
    }
    if (options.responsive) {
      state.responsive = true;
      url = this.cloudinary_update(url, state);
    }

    let currentState = this.state || {};
    if (!Util.isEmpty(url) &amp;&amp; url !== currentState.url) {
      state.url = url;
    }
    return state;
  }

  handleResize(e) {
    if (this.rqf) return;
    this.rqf = requestAnimationFrame(() => {
      this.rqf = null;
      let newState = this.prepareState();
      if(!Util.isEmpty(newState.url)) {
        this.setState(newState);
      }
    });
  }

  componentDidMount() {
    // now that we have a this.element, we need to calculate the URL
    this.handleResize();
  }

  componentWillUnmount() {
    this.element = undefined;
    if (this.listener) {
      this.listener.cancel();
      this.window &amp;&amp; this.window.removeEventListener('resize', this.listener);
    }
    this.listener = undefined;
  }

  componentWillUpdate(nextProps, nextState, nextContext) {
    if (nextState.responsive) {
      const wait = firstDefined(nextProps.responsiveDebounce, nextContext.responsiveDebounce, 100);
      if (this.listener) {
        this.window &amp;&amp; this.window.removeEventListener('resize', this.listener);
      }
      this.listener = debounce(this.handleResize, wait);
      this.window &amp;&amp; this.window.addEventListener('resize', this.listener);
    }
  }

  render() {
    var {publicId, responsive, responsiveDebounce, children, ...options} = CloudinaryComponent.normalizeOptions(this.props,
      this.context);
    var attributes = cloudinary.Transformation.new(options).toHtmlAttributes();
    return (
      &lt;img {...attributes} src={this.state.url} ref={(e)=> {this.element = e;}}/>
    );
  }

  // Methods from cloudinary_js

  findContainerWidth() {
    var containerWidth, style;
    containerWidth = 0;
    let element = this.element;
    while (isElement((element = element != null ? element.parentNode : void 0)) &amp;&amp; !containerWidth) {
      style = this.window ? this.window.getComputedStyle(element) : '';
      if (!/^inline/.test(style.display)) {
        containerWidth = Util.width(element);
      }
    }
    return containerWidth;
  };

  applyBreakpoints(width, steps, options) {
    var responsive_use_breakpoints;
    options = CloudinaryComponent.normalizeOptions(this.context, this.props, options);
    responsive_use_breakpoints = options.responsiveUseBreakpoints;
    if ((!responsive_use_breakpoints) || (responsive_use_breakpoints === 'resize' &amp;&amp; !options.resizing)) {
      return width;
    } else {
      return this.calc_breakpoint(width, steps);
    }
  };

  calc_breakpoint(width, steps) {
    var breakpoints, point;
    breakpoints = this.state.breakpoints || defaultBreakpoints;
    if (Util.isFunction(breakpoints)) {
      return breakpoints(width, steps);
    } else {
      if (Util.isString(breakpoints)) {
        breakpoints = ((function () {
          var j, len, ref, results;
          ref = breakpoints.split(',');
          results = [];
          for (j = 0, len = ref.length; j &lt; len; j++) {
            point = ref[j];
            results.push(parseInt(point));
          }
          return results;
        })()).sort(function (a, b) {
          return a - b;
        });
      }
      return closestAbove(breakpoints, width);
    }
  };

  device_pixel_ratio(roundDpr = true) {
    var dpr, dprString;
    dpr = (typeof this.window !== "undefined" &amp;&amp; this.window !== null ? this.window.devicePixelRatio : void 0) || 1;
    if (roundDpr) {
      dpr = Math.ceil(dpr);
    }
    if (dpr &lt;= 0 || isNaN(dpr)) {
      dpr = 1;
    }
    dprString = dpr.toString();
    if (dprString.match(/^\d+$/)) {
      dprString += '.0';
    }
    return dprString;
  };

  updateDpr(dataSrc, roundDpr) {
    return dataSrc.replace(/\bdpr_(1\.0|auto)\b/g, 'dpr_' + this.device_pixel_ratio(roundDpr));
  };

  maxWidth(requiredWidth) {
    var imageWidth;
    imageWidth = this.state.width || 0;
    if (requiredWidth > imageWidth) {
      imageWidth = requiredWidth;
      this.setState({width: requiredWidth});
    }
    return imageWidth;
  };

  cloudinary_update(url, options = {}) {
    var requiredWidth;
    var match;
    let resultUrl = this.updateDpr(url, options.roundDpr);
    if (options.responsive || this.state &amp;&amp; this.state.responsive) {
      let containerWidth = this.findContainerWidth();
      if (containerWidth !== 0) {
        if (/w_auto:breakpoints/.test(resultUrl)) {
          requiredWidth = this.maxWidth(containerWidth, this.element);
          resultUrl = resultUrl.replace(/w_auto:breakpoints([_0-9]*)(:[0-9]+)?/,
            "w_auto:breakpoints$1:" + requiredWidth);
        } else if (match = /w_auto(:(\d+))?/.exec(resultUrl)) {
          requiredWidth = this.applyBreakpoints(containerWidth, match[2], options);
          requiredWidth = this.maxWidth(requiredWidth, this.element);
          resultUrl = resultUrl.replace(/w_auto[^,\/]*/g, "w_" + requiredWidth);
        }
      } else {
        resultUrl = "";
      }
    }
    return resultUrl;
  }
}

Image.defaultProps = {};
Image.contextTypes = CloudinaryComponent.contextTypes;
Image.propTypes = CloudinaryComponent.propTypes;

export default Image;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CloudinaryComponent.html">CloudinaryComponent</a></li><li><a href="CloudinaryContext.html">CloudinaryContext</a></li><li><a href="Image.html">Image</a></li><li><a href="Transformation.html">Transformation</a></li><li><a href="Video.html">Video</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Wed Mar 01 2017 15:23:31 GMT+0200 (IST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
